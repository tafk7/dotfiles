# Bash configuration
# Owns: shell options, history, completion, prompt, bash-specific tool loading

# PATH baseline — ~/.profile handles this for login shells, but VS Code and other
# terminals launch bash as non-login (skipping ~/.profile). Profile has a source
# guard so this is safe in both login and non-login shells.
[[ -f "$HOME/.profile" ]] && source "$HOME/.profile"

# Load install-time environment (written by setup.sh)
[[ -f "$HOME/.config/dotfiles/env" ]] && source "$HOME/.config/dotfiles/env"

# Fallback: derive DOTFILES_DIR from symlink if env file is missing
if [[ -z "$DOTFILES_DIR" ]]; then
    DOTFILES_DIR="$(dirname "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")")"
    export DOTFILES_DIR
fi
: ${DOTFILES_DIR:="$HOME/dotfiles"}

# ==============================================================================
# Core Shell Settings
# ==============================================================================

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

# Shell options
shopt -s histappend                # Append to history, don't overwrite
shopt -s checkwinsize              # Check window size after each command
shopt -s globstar                  # Enable ** recursive globbing
shopt -s extglob                  # Extended globbing patterns

# Completion
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

complete -cf sudo
complete -cf man

# ==============================================================================
# History
# ==============================================================================

HISTFILE=~/.bash_history
HISTSIZE=${BASH_HIST_SIZE:-50000}
HISTFILESIZE=$((HISTSIZE * 2))
HISTCONTROL=ignoreboth:erasedups
HISTTIMEFORMAT="%F %T "
HISTIGNORE=""

# Real-time history sharing
PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND$'\n'}history -a"

# ==============================================================================
# Load Shared Environment
# ==============================================================================

# Tool initialization (version managers, EDITOR, tool-specific settings, WSL env)
[[ -f "$DOTFILES_DIR/shell/env.sh" ]] && source "$DOTFILES_DIR/shell/env.sh"

# FZF configuration (commands, preview options)
[[ -f "$DOTFILES_DIR/shell/fzf.sh" ]] && source "$DOTFILES_DIR/shell/fzf.sh"

# Theme (prompt colors, FZF color scheme)
[[ -f "$HOME/.config/dotfiles/theme.sh" ]] && source "$HOME/.config/dotfiles/theme.sh"

# ==============================================================================
# FZF Key Bindings (bash-specific)
# ==============================================================================

if command -v fzf >/dev/null 2>&1; then
    [[ -f /usr/share/doc/fzf/examples/key-bindings.bash ]] && \
        source /usr/share/doc/fzf/examples/key-bindings.bash
    [[ -f /usr/share/doc/fzf/examples/completion.bash ]] && \
        source /usr/share/doc/fzf/examples/completion.bash
fi

# ==============================================================================
# Prompt
# ==============================================================================

# Git-aware prompt (disable with: export BASH_NO_GIT_PROMPT=1)
git_prompt() {
    [[ -n "$BASH_NO_GIT_PROMPT" ]] && return

    local git_status git_branch
    if git_branch=$(timeout 0.1s git symbolic-ref --short HEAD 2>/dev/null); then
        git_status=$(timeout 0.2s git status --porcelain 2>/dev/null)
        if [[ -n $git_status ]]; then
            echo " ${PROMPT_COLOR_GIT_DIRTY}($git_branch*)${PROMPT_COLOR_RESET}"
        else
            echo " ${PROMPT_COLOR_GIT_CLEAN}($git_branch)${PROMPT_COLOR_RESET}"
        fi
    fi
}

# Default prompt colors (overridden by theme if loaded)
if [[ -z "$PROMPT_COLOR_USER" ]]; then
    export PROMPT_COLOR_USER='\[\e[38;5;108m\]'
    export PROMPT_COLOR_HOST='\[\e[38;5;214m\]'
    export PROMPT_COLOR_PATH='\[\e[38;5;108m\]'
    export PROMPT_COLOR_GIT_CLEAN='\[\e[38;5;142m\]'
    export PROMPT_COLOR_GIT_DIRTY='\[\e[38;5;167m\]'
    export PROMPT_COLOR_SUCCESS='\[\e[38;5;142m\]'
    export PROMPT_COLOR_ERROR='\[\e[38;5;167m\]'
    export PROMPT_COLOR_RESET='\[\e[0m\]'
fi

set_prompt() {
    local exit_code=$?
    local prompt_symbol

    if [[ $exit_code -ne 0 ]]; then
        prompt_symbol="${PROMPT_COLOR_ERROR}✗${PROMPT_COLOR_RESET}"
    else
        prompt_symbol="${PROMPT_COLOR_SUCCESS}✓${PROMPT_COLOR_RESET}"
    fi

    PS1="${PROMPT_COLOR_USER}\u${PROMPT_COLOR_RESET}@${PROMPT_COLOR_HOST}\h${PROMPT_COLOR_RESET}:${PROMPT_COLOR_PATH}\w${PROMPT_COLOR_RESET}"
    PS1+="$(git_prompt)"
    PS1+=" ${prompt_symbol} "
}

PROMPT_COMMAND="set_prompt; $PROMPT_COMMAND"

# ==============================================================================
# NVM
# ==============================================================================

[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

# ==============================================================================
# Shared Functions and Aliases
# ==============================================================================

if [[ -d "$DOTFILES_DIR" ]]; then
    [[ -f "$DOTFILES_DIR/shell/functions.sh" ]] && source "$DOTFILES_DIR/shell/functions.sh"

    for file in "$DOTFILES_DIR"/shell/aliases/*.sh; do
        [[ -r "$file" ]] && source "$file" 2>/dev/null || true
    done
fi

# ==============================================================================
# Local Overrides (not tracked in git)
# ==============================================================================

[[ -f ~/.shell.local ]] && source ~/.shell.local
[[ -f ~/.bashrc.local ]] && source ~/.bashrc.local
