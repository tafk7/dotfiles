#!/bin/bash
# Dotfiles Cheat Sheet - Quick reference for all keybindings and shortcuts
# Part of dotfiles - compact display of vim, tmux, git, and shell shortcuts

set -e

# Source core functions for colors
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Navigate up one directory since we're now in bin/
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"
source "$DOTFILES_DIR/lib.sh"

# Terminal width detection
TERM_WIDTH=$(tput cols 2>/dev/null || echo 80)

# Color definitions using tput for better compatibility
if command -v tput >/dev/null 2>&1 && [[ -t 1 ]]; then
    BOLD=$(tput bold)
    CYAN=$(tput setaf 6)
    YELLOW=$(tput setaf 3)
    DIM=$(tput dim)
    RESET=$(tput sgr0)
else
    BOLD=""
    CYAN=""
    YELLOW=""
    DIM=""
    RESET=""
fi

# Print section header
print_header() {
    local title="$1"
    echo
    echo "${BOLD}${CYAN}${title}${RESET}"
}

# Print table separator
print_separator() {
    printf "${DIM}"
    printf 'â”€%.0s' $(seq 1 "$TERM_WIDTH")
    printf "${RESET}\n"
}

# Format keybinding line with colors
format_line() {
    echo "$1" | sed -E "s/([^ ]+)( +)([^â”‚]+)/\\1\\2${DIM}\\3${RESET}/g" | \
                sed -E "s/^([^ ]+)/    ${YELLOW}\\1${RESET}/"
}

# Show vim keybindings
show_vim() {
    print_header "VIM KEYBINDINGS"
    echo "    Navigation          Git                Code               Windows"
    print_separator
    format_line "Ctrl+P  Files       ,gs  Status        ,af  Fix          Ctrl+E  Up"
    format_line ",f      Files       ,gd  Diff          ,an  Next err     Ctrl+S  Left"
    format_line ",b      Buffers     ,gb  Blame         ,ap  Prev err     Ctrl+D  Down"
    format_line ",g      Grep        ,hn  Next hunk     ,/   Comment      Ctrl+F  Right"
    format_line "Space   Clear hl    ,hs  Stage hunk    ,n   Line nums    "
    format_line "jk      Escape      ,hu  Undo hunk     ,ss  Strip space  "
    echo
    echo "    Text Manipulation   File Operations    FZF Tips           Misc"
    print_separator
    format_line "cs\"'    \" â†’ '       ,w   Save (force)  Ctrl+/  Preview    ,q   Quit"
    format_line "ds\"     Delete \"    ,Q   Quit all      Tab     Multi-sel  ,Q   Quit all"
    format_line "ysiw\"   Add \"       :w   Save          Enter   Open       u    Undo"
    format_line "gc      Comment     :q   Quit                             .    Repeat"
}

# Show tmux keybindings
show_tmux() {
    print_header "TMUX KEYBINDINGS (Prefix: Ctrl+a)"
    echo "    Panes               Windows            Sessions           Config"
    print_separator
    format_line "|    Split horiz    c    New           d    Detach       r    Reload"
    format_line "-    Split vert     1-9  Switch        s    List         ?    Show keys"
    format_line "x    Kill pane      n    Next          $    Rename       "
    format_line "X    Kill window    p    Previous      (    Previous     "
    echo
    echo "    Navigation (No Prefix)              Resizing (With Prefix)"
    print_separator
    format_line "Alt+E    Up         Alt+1-9  Window   Shift+â†‘    Up 5    E    Up 5"
    format_line "Alt+S    Left                         Shift+â†    Left 5  S    Left 5"
    format_line "Alt+D    Down                         Shift+â†“    Down 5  D    Down 5"
    format_line "Alt+F    Right                        Shift+â†’    Right 5 F    Right 5"
}

# Show git aliases
show_git() {
    print_header "GIT ALIASES"
    echo "    Status              Staging            Commits            Branches"
    print_separator
    format_line "gs   status         ga   add           gc   commit        gsw  switch"
    format_line "gl   log graph      gaa  add all       gcm  commit -m     gswc switch -c"
    format_line "gla  log all        gau  add -u        gca  amend         gb   branch"
    format_line "gd   diff           grs  restore       "
    format_line "gds  diff staged    grss restore --staged"
    echo
    echo "    Fetch               Push/Pull          Stash              Other"
    print_separator
    format_line "gf   fetch          gp   push          gst  stash         gcl  clone"
    format_line "gfo  fetch origin   gpl  pull          gstp stash pop     lg   lazygit"
    format_line "gfu  fetch upstream gpu  push -u       gsta stash apply   "
    format_line "gfa  fetch --all    "
    format_line "gfp  fetch --prune  "
    echo
    echo "    Functions                            Usage"
    print_separator
    format_line "gundo              Undo last commit (keep changes)"
    format_line "gquick \"message\"   Add all, commit, and push"
}

# Show shell shortcuts
show_shell() {
    print_header "SHELL ALIASES & SHORTCUTS"
    echo "    Navigation          File Operations    System Info        Network"
    print_separator
    format_line "..   Parent dir     ls   List (eza)    df   Disk free     myip    Public IP"
    format_line "...  Up 2 dirs      ll   Long list     du   Disk usage    localip Local IP"
    format_line "~    Home dir       la   All files     free Memory        ports   Open ports"
    format_line "-    Previous dir   tree Tree view     psg  Find process  note    Quick notes"
    echo
    echo "    Modern Tools        Archive            Dotfiles           FZF Extras"
    print_separator
    format_line "bat  Better cat     untar Extract      reload   Reload    fgb    Git branch"
    format_line "fd   Find files     tarc  Create tar   themes   List      fgl    Git log"
    format_line "rg   Ripgrep        fr    Find/replace theme-switch       frg    Ripgrep+fzf"
    format_line "vim  Neovim         extract Archive     update-configs    fp     Projects"
    echo
    echo "    Tmux Shortcuts      Safer Commands     Quick Actions      Claude"
    print_separator
    format_line "tm   New session    rmff Force remove  psmem  Sort by RAM   cl     New"
    format_line "ta   Attach         rmi  Interactive   pscpu  Sort by CPU   clc    Continue"
    format_line "tl   List sessions  cpv  Verbose copy  ducks  Large files   clp    Print"
    format_line "tk   Kill session   rmv  Verbose rm    md     View markdown cheat  Help"
}

# Show development tools
show_dev() {
    print_header "DEVELOPMENT SHORTCUTS"
    echo "    Python              Node.js            Docker             General"
    print_separator
    format_line "py   Python3        ni   npm install   dps  List          vimvim Real vim"
    format_line "venv Create venv    nr   npm run      di   Images        vivim  Real vi"
    format_line "activate Activate   nrd  npm run dev  dc   Compose       fr     Find/replace"
    format_line "pytest Run tests    nrb  npm run build dcu  Up           "
    format_line "fmt  Black format   nrt  npm run test  dcd  Down         "
    format_line "lint Ruff check     nclean Reinstall   dprune Clean       "
}

# Show all cheatsheets
show_all() {
    show_vim
    show_tmux
    show_git
    show_shell
    show_dev
}

# Build comprehensive searchable index of all shortcuts
# Format: categoryâ”‚shortcutâ”‚descriptionâ”‚full_command
# Reads from shell/shortcuts-index.tsv
build_shortcut_index() {
    local index_file="$DOTFILES_DIR/shell/shortcuts-index.tsv"

    if [[ ! -f "$index_file" ]]; then
        echo "Error: Shortcuts index not found at $index_file" >&2
        return 1
    fi

    # Read the file, skipping comments and empty lines
    grep -v '^#' "$index_file" | grep -v '^$'
}

# Show detailed information about a specific shortcut
show_shortcut_detail() {
    local category="$1"
    local shortcut="$2"

    # Get the full line from the index
    local detail=$(build_shortcut_index | grep "^${category}â”‚${shortcut}â”‚")

    if [[ -n "$detail" ]]; then
        local desc=$(echo "$detail" | cut -d'â”‚' -f3)
        local cmd=$(echo "$detail" | cut -d'â”‚' -f4)

        echo ""
        echo "${BOLD}${YELLOW}${shortcut}${RESET}"
        echo "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo "${CYAN}Category:${RESET}    ${category}"
        echo "${CYAN}Usage:${RESET}       ${desc}"
        echo "${CYAN}Command:${RESET}     ${cmd}"
        echo ""

        # Add context-specific tips
        case "$category" in
            git)
                echo "${DIM}ðŸ’¡ Tip: Type 'cheat git' for all git shortcuts${RESET}"
                ;;
            tmux)
                echo "${DIM}ðŸ’¡ Tip: Prefix is Ctrl+a (change with TMUX_PREFIX)${RESET}"
                ;;
            vim)
                echo "${DIM}ðŸ’¡ Tip: Leader key is comma (,)${RESET}"
                ;;
        esac
    else
        echo ""
        echo "${DIM}No details available${RESET}"
        echo ""
    fi
}

# Export function for FZF preview
export -f show_shortcut_detail
export -f build_shortcut_index

# Interactive FZF selector with searchable shortcuts
show_interactive() {
    # Fallback to traditional view if FZF not available
    if ! command -v fzf >/dev/null 2>&1; then
        show_all | less -R
        return
    fi

    # Color definitions for preview
    if command -v tput >/dev/null 2>&1; then
        local PREVIEW_BOLD=$(tput bold)
        local PREVIEW_CYAN=$(tput setaf 6)
        local PREVIEW_YELLOW=$(tput setaf 3)
        local PREVIEW_DIM=$(tput dim)
        local PREVIEW_RESET=$(tput sgr0)
    else
        local PREVIEW_BOLD=""
        local PREVIEW_CYAN=""
        local PREVIEW_YELLOW=""
        local PREVIEW_DIM=""
        local PREVIEW_RESET=""
    fi

    # Create temporary index file for preview to read
    local index_file=$(mktemp)
    build_shortcut_index > "$index_file"

    # Create temporary file for preview script
    local preview_script=$(mktemp)
    cat > "$preview_script" <<PREVIEW_EOF
#!/bin/bash
# Self-contained preview script - receives original TSV line
BOLD="$PREVIEW_BOLD"
CYAN="$PREVIEW_CYAN"
YELLOW="$PREVIEW_YELLOW"
DIM="$PREVIEW_DIM"
RESET="$PREVIEW_RESET"

# Parse the TSV line directly using awk
line="\$1"
category=\$(echo "\$line" | awk -F'â”‚' '{print \$1}')
shortcut=\$(echo "\$line" | awk -F'â”‚' '{print \$2}')
full_desc=\$(echo "\$line" | awk -F'â”‚' '{print \$3}')
full_cmd=\$(echo "\$line" | awk -F'â”‚' '{print \$4}')

if [[ -n "\$shortcut" ]]; then
    echo ""
    echo "\${BOLD}\${YELLOW}\${shortcut}\${RESET}"
    echo "\${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\${RESET}"
    echo "\${CYAN}Category:\${RESET}    \${category}"
    echo "\${CYAN}Usage:\${RESET}       \${full_desc}"
    echo "\${CYAN}Command:\${RESET}     \${full_cmd}"
    echo ""

    case "\$category" in
        git)
            echo "\${DIM}ðŸ’¡ Tip: Type 'cheat git' for all git shortcuts\${RESET}"
            ;;
        tmux)
            echo "\${DIM}ðŸ’¡ Tip: Prefix is Ctrl+a\${RESET}"
            ;;
        vim)
            echo "\${DIM}ðŸ’¡ Tip: Leader key is comma (,)\${RESET}"
            ;;
        docker)
            echo "\${DIM}ðŸ’¡ Tip: 'd' prefix for all docker commands\${RESET}"
            ;;
        python)
            echo "\${DIM}ðŸ’¡ Tip: Use 'venv' to create virtual environments\${RESET}"
            ;;
        node)
            echo "\${DIM}ðŸ’¡ Tip: 'nr' = npm run, 'ni' = npm install\${RESET}"
            ;;
    esac
else
    echo ""
    echo "\${DIM}No details available\${RESET}"
    echo ""
fi
PREVIEW_EOF
    chmod +x "$preview_script"

    # Build searchable index with visible delimiters for display
    local selected=$({
        # Add column headers with visible delimiters
        printf "${BOLD}%-10s â”‚ %-15s â”‚ %-40s â”‚ %s${RESET}\n" "CATEGORY" "SHORTCUT" "DESCRIPTION" "COMMAND"
        # Add separator line
        printf "${DIM}%-10sâ”€â”¼â”€%-15sâ”€â”¼â”€%-40sâ”€â”¼â”€%s${RESET}\n" "$(printf 'â”€%.0s' {1..10})" "$(printf 'â”€%.0s' {1..15})" "$(printf 'â”€%.0s' {1..40})" "$(printf 'â”€%.0s' {1..20})"
        # Format all shortcuts with visible delimiters (but keep original data after display separator)
        cat "$index_file" | awk -F'â”‚' '{
            # Format for display with visible separators
            display = sprintf("%-10s â”‚ %-15s â”‚ %-40s â”‚ %s", $1, $2, $3, $4)
            # Append original line after a special marker for easy extraction
            print display "â•‘" $0
        }'
    } | \
        fzf --ansi \
            --prompt='ðŸ” Search shortcuts > ' \
            --header='Type: shortcut name, description, or category | Enter: Copy command | Esc: Cancel' \
            --header-lines=2 \
            --delimiter='â•‘' \
            --with-nth=1 \
            --preview="echo {2} | $preview_script /dev/stdin" \
            --preview-window='top:10:wrap:rounded:border-rounded' \
            --height=100% \
            --border=rounded \
            --color='header:italic:cyan,prompt:bold:yellow')

    # Clean up temporary files
    rm -f "$preview_script" "$index_file"

    # If user selected something, extract the original TSV data (after â•‘) and get command
    if [[ -n "$selected" ]]; then
        local original=$(echo "$selected" | cut -d'â•‘' -f2)
        local command=$(echo "$original" | awk -F'â”‚' '{print $4}')
        echo ""
        echo "${BOLD}${CYAN}Command:${RESET} ${YELLOW}${command}${RESET}"
        echo ""
        echo "${DIM}ðŸ’¡ Tip: Use Ctrl+Shift+C to copy from terminal${RESET}"
        echo ""
    fi
}

# Main function
main() {
    case "${1}" in
        vim)
            show_vim
            ;;
        tmux)
            show_tmux
            ;;
        git)
            show_git
            ;;
        shell)
            show_shell
            ;;
        dev)
            show_dev
            ;;
        all)
            show_all
            ;;
        "")
            # No args - show interactive selector
            show_interactive
            ;;
        *)
            echo "Usage: cheat [vim|tmux|git|shell|dev|all]"
            echo "Show keybindings and shortcuts for dotfiles tools"
            echo ""
            echo "Run 'cheat' with no arguments for interactive mode"
            exit 1
            ;;
    esac
}

# Handle piping to less for long output when showing specific sections
if [[ -t 1 ]] && [[ -n "$1" ]] && [[ "$1" != "all" ]]; then
    # Direct access to specific section - show in less
    main "$@" | less -R
elif [[ -t 1 ]] && [[ "$1" == "all" ]]; then
    # Direct access to all sections - show in less
    main "$@" | less -R
elif [[ -t 1 ]] && [[ -z "$1" ]]; then
    # No args - interactive mode handles its own display
    main "$@"
else
    # Output is piped
    main "$@"
fi