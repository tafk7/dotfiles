#!/bin/bash
# Dotfiles Cheat Sheet - Quick reference for all keybindings and shortcuts
# Part of dotfiles - compact display of vim, tmux, git, and shell shortcuts

set -e

# Source core functions for colors
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Navigate up one directory since we're now in bin/
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"
source "$DOTFILES_DIR/lib.sh"

# Terminal width detection
TERM_WIDTH=$(tput cols 2>/dev/null || echo 80)

# Color definitions using tput for better compatibility
if command -v tput >/dev/null 2>&1 && [[ -t 1 ]]; then
    BOLD=$(tput bold)
    CYAN=$(tput setaf 6)
    YELLOW=$(tput setaf 3)
    DIM=$(tput dim)
    RESET=$(tput sgr0)
else
    BOLD=""
    CYAN=""
    YELLOW=""
    DIM=""
    RESET=""
fi

# Print section header
print_header() {
    local title="$1"
    echo
    echo "${BOLD}${CYAN}${title}${RESET}"
}

# Print table separator
print_separator() {
    printf "${DIM}"
    printf 'â”€%.0s' $(seq 1 "$TERM_WIDTH")
    printf "${RESET}\n"
}

# Format shortcut in two-column table (shortcut on left, description on right)
format_shortcut() {
    local shortcut="$1"
    local description="$2"
    printf "    ${YELLOW}%-15s${RESET} %s\n" "$shortcut" "$description"
}

# Show shortcuts for a specific category from TSV
show_category() {
    local category="$1"
    local title="$2"

    print_header "$title"

    # Filter shortcuts by category and format
    build_shortcut_index | grep "^${category}â”‚" | while IFS='â”‚' read -r cat shortcut description command; do
        format_shortcut "$shortcut" "$description"
    done
}

# Show vim keybindings
show_vim() {
    show_category "vim" "VIM KEYBINDINGS"
}

# Show tmux keybindings
show_tmux() {
    show_category "tmux" "TMUX KEYBINDINGS (Prefix: Ctrl+a)"
}

# Show git aliases
show_git() {
    show_category "git" "GIT ALIASES"
}

# Show shell shortcuts
show_shell() {
    show_category "shell" "SHELL ALIASES & SHORTCUTS"
}

# Show development tools (combines docker, python, node)
show_dev() {
    print_header "DEVELOPMENT SHORTCUTS"

    echo
    echo "${BOLD}Docker${RESET}"
    build_shortcut_index | grep "^dockerâ”‚" | while IFS='â”‚' read -r cat shortcut description command; do
        format_shortcut "$shortcut" "$description"
    done

    echo
    echo "${BOLD}Python${RESET}"
    build_shortcut_index | grep "^pythonâ”‚" | while IFS='â”‚' read -r cat shortcut description command; do
        format_shortcut "$shortcut" "$description"
    done

    echo
    echo "${BOLD}Node.js${RESET}"
    build_shortcut_index | grep "^nodeâ”‚" | while IFS='â”‚' read -r cat shortcut description command; do
        format_shortcut "$shortcut" "$description"
    done
}

# Show all cheatsheets
show_all() {
    show_vim
    show_tmux
    show_git
    show_shell
    show_dev
}

# Build comprehensive searchable index of all shortcuts
# Format: categoryâ”‚shortcutâ”‚descriptionâ”‚full_command
# Reads from shell/shortcuts-index.tsv
build_shortcut_index() {
    local index_file="$DOTFILES_DIR/shell/shortcuts-index.tsv"

    if [[ ! -f "$index_file" ]]; then
        echo "Error: Shortcuts index not found at $index_file" >&2
        return 1
    fi

    # Read the file, skipping comments and empty lines
    grep -v '^#' "$index_file" | grep -v '^$'
}

# Show detailed information about a specific shortcut
show_shortcut_detail() {
    local category="$1"
    local shortcut="$2"

    # Get the full line from the index
    local detail=$(build_shortcut_index | grep "^${category}â”‚${shortcut}â”‚")

    if [[ -n "$detail" ]]; then
        local desc=$(echo "$detail" | cut -d'â”‚' -f3)
        local cmd=$(echo "$detail" | cut -d'â”‚' -f4)

        echo ""
        echo "${BOLD}${YELLOW}${shortcut}${RESET}"
        echo "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo "${CYAN}Category:${RESET}    ${category}"
        echo "${CYAN}Usage:${RESET}       ${desc}"
        echo "${CYAN}Command:${RESET}     ${cmd}"
        echo ""

        # Add context-specific tips
        case "$category" in
            git)
                echo "${DIM}ðŸ’¡ Tip: Type 'cheat git' for all git shortcuts${RESET}"
                ;;
            tmux)
                echo "${DIM}ðŸ’¡ Tip: Prefix is Ctrl+a (change with TMUX_PREFIX)${RESET}"
                ;;
            vim)
                echo "${DIM}ðŸ’¡ Tip: Leader key is comma (,)${RESET}"
                ;;
        esac
    else
        echo ""
        echo "${DIM}No details available${RESET}"
        echo ""
    fi
}

# Export function for FZF preview
export -f show_shortcut_detail
export -f build_shortcut_index

# Interactive FZF selector with searchable shortcuts
show_interactive() {
    # Fallback to traditional view if FZF not available
    if ! command -v fzf >/dev/null 2>&1; then
        show_all | less -R
        return
    fi

    # Color definitions for preview
    if command -v tput >/dev/null 2>&1; then
        local PREVIEW_BOLD=$(tput bold)
        local PREVIEW_CYAN=$(tput setaf 6)
        local PREVIEW_YELLOW=$(tput setaf 3)
        local PREVIEW_DIM=$(tput dim)
        local PREVIEW_RESET=$(tput sgr0)
    else
        local PREVIEW_BOLD=""
        local PREVIEW_CYAN=""
        local PREVIEW_YELLOW=""
        local PREVIEW_DIM=""
        local PREVIEW_RESET=""
    fi

    # Create temporary index file for preview to read
    local index_file=$(mktemp)
    build_shortcut_index > "$index_file"

    # Create temporary file for preview script
    local preview_script=$(mktemp)
    cat > "$preview_script" <<PREVIEW_EOF
#!/bin/bash
# Self-contained preview script - receives original TSV line via stdin
BOLD="$PREVIEW_BOLD"
CYAN="$PREVIEW_CYAN"
YELLOW="$PREVIEW_YELLOW"
DIM="$PREVIEW_DIM"
RESET="$PREVIEW_RESET"

# Read the TSV line from stdin
line=\$(cat)
category=\$(echo "\$line" | awk -F'â”‚' '{print \$1}')
shortcut=\$(echo "\$line" | awk -F'â”‚' '{print \$2}')
full_desc=\$(echo "\$line" | awk -F'â”‚' '{print \$3}')
full_cmd=\$(echo "\$line" | awk -F'â”‚' '{print \$4}')

if [[ -n "\$shortcut" ]]; then
    echo ""
    echo "\${BOLD}\${YELLOW}\${shortcut}\${RESET}"
    echo "\${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\${RESET}"
    echo "\${CYAN}Category:\${RESET}     \${category}"
    echo "\${CYAN}Command:\${RESET}      \${full_cmd}"
    echo "\${CYAN}Description:\${RESET}  \${full_desc}"
    echo ""

    case "\$category" in
        git)
            echo "\${DIM}ðŸ’¡ Tip: Type 'cheat git' for all git shortcuts\${RESET}"
            ;;
        tmux)
            echo "\${DIM}ðŸ’¡ Tip: Prefix is Ctrl+a\${RESET}"
            ;;
        vim)
            echo "\${DIM}ðŸ’¡ Tip: Leader key is comma (,)\${RESET}"
            ;;
        docker)
            echo "\${DIM}ðŸ’¡ Tip: 'd' prefix for all docker commands\${RESET}"
            ;;
        python)
            echo "\${DIM}ðŸ’¡ Tip: Use 'venv' to create virtual environments\${RESET}"
            ;;
        node)
            echo "\${DIM}ðŸ’¡ Tip: 'nr' = npm run, 'ni' = npm install\${RESET}"
            ;;
    esac
else
    echo ""
    echo "\${DIM}No details available\${RESET}"
    echo ""
fi
PREVIEW_EOF
    chmod +x "$preview_script"

    # Build searchable index with visible delimiters for display
    local selected=$({
        # Add column headers with visible delimiters (3 columns: category, shortcut, command)
        printf "${BOLD}%-10s â”‚ %-15s â”‚ %s${RESET}\n" "CATEGORY" "SHORTCUT" "COMMAND"
        # Add separator line
        printf "${DIM}%-10sâ”€â”¼â”€%-15sâ”€â”¼â”€%s${RESET}\n" "$(printf 'â”€%.0s' {1..10})" "$(printf 'â”€%.0s' {1..15})" "$(printf 'â”€%.0s' {1..50})"
        # Format all shortcuts with visible delimiters (show only category, shortcut, command)
        cat "$index_file" | awk -F'â”‚' '{
            # Format for display with visible separators (3 columns, no description in search)
            display = sprintf("%-10s â”‚ %-15s â”‚ %s", $1, $2, $4)
            # Append original line after a tab separator (invisible, clean split)
            print display "\t" $0
        }'
    } | \
        fzf --ansi \
            --prompt='ðŸ” Search shortcuts > ' \
            --header='Type: shortcut name, description, or category | Enter: Copy command | Esc: Cancel' \
            --header-lines=2 \
            --delimiter='\t' \
            --with-nth=1 \
            --preview="echo {2} | $preview_script" \
            --preview-window='top:10:wrap:rounded:border-rounded' \
            --height=100% \
            --border=rounded \
            --color='header:italic:cyan,prompt:bold:yellow')

    # Clean up temporary files
    rm -f "$preview_script" "$index_file"

    # If user selected something, extract the original TSV data (after tab) and get command
    if [[ -n "$selected" ]]; then
        local original=$(echo "$selected" | cut -f2)
        local command=$(echo "$original" | awk -F'â”‚' '{print $4}')
        echo ""
        echo "${BOLD}${CYAN}Command:${RESET} ${YELLOW}${command}${RESET}"
        echo ""
        echo "${DIM}ðŸ’¡ Tip: Use Ctrl+Shift+C to copy from terminal${RESET}"
        echo ""
    fi
}

# Main function
main() {
    case "${1}" in
        vim)
            show_vim
            ;;
        tmux)
            show_tmux
            ;;
        git)
            show_git
            ;;
        shell)
            show_shell
            ;;
        dev)
            show_dev
            ;;
        all)
            show_all
            ;;
        "")
            # No args - show interactive selector
            show_interactive
            ;;
        *)
            echo "Usage: cheat [vim|tmux|git|shell|dev|all]"
            echo "Show keybindings and shortcuts for dotfiles tools"
            echo ""
            echo "Run 'cheat' with no arguments for interactive mode"
            exit 1
            ;;
    esac
}

# Handle piping to less for long output when showing specific sections
if [[ -t 1 ]] && [[ -n "$1" ]] && [[ "$1" != "all" ]]; then
    # Direct access to specific section - show in less
    main "$@" | less -R
elif [[ -t 1 ]] && [[ "$1" == "all" ]]; then
    # Direct access to all sections - show in less
    main "$@" | less -R
elif [[ -t 1 ]] && [[ -z "$1" ]]; then
    # No args - interactive mode handles its own display
    main "$@"
else
    # Output is piped
    main "$@"
fi